# azure-pipelines-backend.yml for BarberMatch (Nest.js)

trigger:
  branches:
    include:
    - main
    - master
    - develop
    - feature/*

# [R√∫brica] Disparo por Pull Request
pr:
  branches:
    include:
    - main
    - master
    - develop

variables:
  # Tecnolog√≠as: Nest.js (Node.js/TypeScript)
  nodeVersion: '20.x' 
  vmImageName: 'ubuntu-latest'
  artifactName: 'backend-dist-package'
  
  # --- CONEXI√ìN CON SONARCLOUD ---
  sonarCloudServiceConnection: 'SonarQube-Back'
  sonarCloudOrganization: 'iduertom'
  sonarCloudProjectKey: 'iduertom_backend' # Clave confirmada
  
  # --- CONEXI√ìN CON AZURE ---
  azureSubscription: 'AzureServiceConnection'
  resourceGroupName: 'barbermatch-rg'
  webAppName: 'iduertom_backend-api-$(Build.BuildId)'
  deployedUrl: 'https://iduertom_backend-api-$(Build.BuildId).azurewebsites.net'

pool:
  vmImage: $(vmImageName)

stages:
# ------------------------------------------------------------------------
# STAGE 1: BUILD, TEST & PACKAGE 
# ------------------------------------------------------------------------
- stage: Build
  displayName: 'üèóÔ∏è Build, Test & Package Backend'
  jobs:
  - job: BackendBuild
    displayName: 'NestJS Compilation & Testing'
    steps:
    - task: NodeTool@0
      displayName: 'üîß Install Node.js $(nodeVersion)'
      inputs:
        versionSpec: $(nodeVersion)

    - script: |
        npm ci
        npm run build 
      displayName: 'üì¶ Install Dependencies & Compile'
      
    - script: |
        echo "##[section] Running Unit Tests with Coverage (Requisito de Testabilidad)"
        npm run test:cov 
      displayName: 'üß™ Run Unit Tests & Generate Coverage'
      
    - task: PublishBuildArtifacts@1
      displayName: 'üì¶ Publish Build Artifacts'
      inputs:
        PathtoPublish: '$(System.DefaultWorkingDirectory)/dist' 
        ArtifactName: '$(artifactName)'
        
# ------------------------------------------------------------------------
# STAGE 2: SONARCLOUD
# ------------------------------------------------------------------------
- stage: SonarCloud
  displayName: 'üî¨ SonarCloud Analysis'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: Analyze
    displayName: 'Scan NestJS Code'
    steps:
    - checkout: self
      fetchDepth: 0
      
    - task: NodeTool@0
      displayName: 'üîß Install Node.js $(nodeVersion) for Sonar'
      inputs:
        versionSpec: $(nodeVersion)
    
    - script: |
        npm ci
        npm run test:cov
      displayName: 'üìä Regenerate Coverage for SonarCloud'
      
    - task: SonarCloudPrepare@3
      displayName: 'üîß Prepare SonarCloud'
      inputs:
        SonarCloud: '$(sonarCloudServiceConnection)'
        organization: '$(sonarCloudOrganization)'
        scannerMode: 'CLI'
        configMode: 'file'
        
    - script: |
        cat > sonar-project.properties << EOF
        sonar.projectKey=iduertom_backend
        sonar.projectName=BarberMatch Backend API
        sonar.sources=src
        sonar.language=ts
        sonar.sourceEncoding=UTF-8
        sonar.javascript.lcov.reportPaths=coverage/lcov.info
        sonar.exclusions=**/*.spec.ts,**/*.test.ts,**/node_modules/**,**/dist/**,**/coverage/**
        sonar.tests=src
        sonar.test.inclusions=**/*.spec.ts,**/*.test.ts
        sonar.coverage.exclusions=**/*.spec.ts,**/*.test.ts
        EOF
        cat sonar-project.properties
      displayName: 'üìù Create sonar-project.properties with verification'
          
    - task: SonarCloudAnalyze@3
      displayName: 'üîç Run Code Analysis'
    
    - task: SonarCloudPublish@3
      displayName: 'üìä Publish Quality Gate Results'
      inputs:
        pollingTimeoutSec: '300' 
      continueOnError: true 

# ------------------------------------------------------------------------
# STAGE 3: DEPLOY (Con la soluci√≥n de Policy Fallback y Pausa)
# ------------------------------------------------------------------------
- stage: Deploy
  displayName: 'üöÄ Deploy to Azure Web App'
  dependsOn: SonarCloud
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))
  jobs:
  - deployment: DeployWebApp
    displayName: 'Deploy Backend'
    environment: 'Production' 
    pool:
      vmImage: $(vmImageName)
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@0
            displayName: 'üì• Download Build Artifacts'
            inputs:
              artifactName: '$(artifactName)'
              downloadPath: '$(System.DefaultWorkingDirectory)' 
              
          # Script de Azure CLI con el FALLBACK MULTI-REGI√ìN + PAUSA DE 10S
          - task: AzureCLI@2
            displayName: 'üèóÔ∏è Create Azure Web App with policy fallback (Delayed Creation)'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -euo pipefail
                
                # --- CONFIGURACI√ìN DE LA APLICACI√ìN ---
                RG_NAME="$(resourceGroupName)"
                PLAN_BASE_NAME="$(resourceGroupName)-plan"
                WEBAPP_NAME="iduertom_backend-api-$(Build.BuildId)" 
                RUNTIME="NODE|$(nodeVersion)"
                SKU_LEVEL="B1" # Usamos B1 para evitar restricciones de F1
                # Lista extendida de regiones para aumentar la probabilidad de √©xito
                LOCATION_LIST=("eastus" "westeurope" "canadacentral" "brazilsouth" "westus3" "eastus2" "westus2" "southcentralus" "centralus" "northeurope")

                # 1. Crear el Grupo de Recursos
                echo "Creando o verificando Grupo de Recursos: $RG_NAME"
                az group create --name "$RG_NAME" --location eastus || true

                SUCCESS=false
                FINAL_LOCATION=""

                # 2. Bucle para intentar crear el plan y la web app en cada regi√≥n
                for LOCATION in "${LOCATION_LIST[@]}"
                do
                  PLAN_NAME="${PLAN_BASE_NAME}-${LOCATION}"
                  echo -e "\n--- Intentando crear plan de servicio en la regi√≥n: $LOCATION ---"

                  # Intentamos crear el App Service Plan
                  if az appservice plan create \
                    --name "$PLAN_NAME" \
                    --resource-group "$RG_NAME" \
                    --location "$LOCATION" \
                    --sku "$SKU_LEVEL" \
                    --is-linux &> /dev/null; then
                    
                    echo -e "‚úÖ √âxito: Plan de servicio creado en $LOCATION (Nombre: $PLAN_NAME)."
                    
                    # üí° SOLUCI√ìN CLAVE: Pausa para dar tiempo a Azure antes de adjuntar la Web App
                    echo "üïí Pausa de 10 segundos para mitigar problemas de concurrencia/saturaci√≥n de Azure..."
                    sleep 10
                    
                    echo "Creando Web App $WEBAPP_NAME en $LOCATION..."
                    # Intentamos crear la Web App
                    if az webapp create \
                      --name "$WEBAPP_NAME" \
                      --resource-group "$RG_NAME" \
                      --plan "$PLAN_NAME" \
                      --runtime "$RUNTIME" &> /dev/null; then
                      
                      echo -e "üéâ √âxito: Web App creada correctamente en $LOCATION."
                      
                      # Configurar el comando de inicio para Nest.js
                      az webapp config set --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --startup-file "npm run start:prod" &> /dev/null || true
                      
                      SUCCESS=true
                      FINAL_LOCATION="$LOCATION"
                      break # √âxito total: salimos del bucle
                    else
                      echo "‚ùå Fallo: El Plan fue creado, pero la Web App fall√≥. Intentando la siguiente regi√≥n."
                      # Limpiamos el plan fallido para liberar cuota (importante)
                      az appservice plan delete --name "$PLAN_NAME" --resource-group "$RG_NAME" --yes &> /dev/null || true
                    fi
                  else
                    echo "‚ùå Fallo: La creaci√≥n del Plan de App Service fue denegada en $LOCATION. Intentando la siguiente regi√≥n."
                  fi
                done

                # 3. Resultado final y exportaci√≥n de variables
                if [ "$SUCCESS" = true ]; then
                  DEPLOYED_URL="https://$WEBAPP_NAME.azurewebsites.net"
                  echo "##vso[task.setvariable variable=webAppName]$WEBAPP_NAME"
                  echo "##vso[task.setvariable variable=deployedUrl]$DEPLOYED_URL"
                  echo -e "\n--- DESPLIEGUE COMPLETO EN AZURE ---"
                  echo "URL de Despliegue: $DEPLOYED_URL"
                else
                  echo -e "\n--- ERROR CR√çTICO ---"
                  echo "No se pudo crear la Web App en ninguna de las regiones intentadas."
                  exit 1
                fi
              
          - task: AzureWebApp@1
            displayName: '‚òÅÔ∏è Deploy Code to Azure: $(webAppName)'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: 'webAppLinux' 
              appName: '$(webAppName)'
              package: '$(System.DefaultWorkingDirectory)/$(artifactName)' 
              runtimeStack: 'NODE|$(nodeVersion)'
              startUpCommand: 'npm run start:prod'

# ------------------------------------------------------------------------
# STAGE 4: PERFORMANCE TEST (JMeter) 
# ------------------------------------------------------------------------
- stage: PerformanceTest
  displayName: '‚ö° JMeter Performance Test'
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: RunJMeter
    displayName: 'Execute Load Test'
    steps:
    - checkout: self
      
    # 1. Instalar JMeter y Java
    - script: |
        sudo apt-get update
        sudo apt-get install default-jre -y 
        wget https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.6.3.zip
        unzip apache-jmeter-5.6.3.zip -d $(System.DefaultWorkingDirectory)
        export JMETER_HOME=$(System.DefaultWorkingDirectory)/apache-jmeter-5.6.3
        export PATH=$PATH:$JMETER_HOME/bin
      displayName: 'üîß Install JMeter'
      
    # 2. Warm-Up / Health Check
    - script: |
        echo "##[section] Waking up the deployed application..."
        APP_URL="$(deployedUrl)/health" # Asume un endpoint de salud
        
        for i in {1..15}; do
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" $APP_URL)
          if [ "$STATUS" -ge 200 ] && [ "$STATUS" -le 404 ]; then
            echo "‚úÖ App is UP and running! (Status: $STATUS)"
            break
          fi
          sleep 10
        done
        echo "‚ùå App failed to start after warm-up."
        exit 1 # Fallar si no se levanta
      displayName: 'üïí Warm-Up / Health Check'
      
    # 3. Ejecutar la prueba JMeter
    - script: |
        echo "##[section] Running JMeter against $(deployedUrl)..."
        TEST_FILE="tests/jmeter/barbermatch-load-test.jmx" 
        RESULTS_FILE="jmeter_results.xml"
        
        jmeter -n -t $TEST_FILE -l $RESULTS_FILE -e -o jmeter_dashboard
      displayName: 'üî• Run JMeter Load Test'
      
    # 4. Publicar resultados como artefacto
    - task: PublishBuildArtifacts@1
      displayName: 'üìä Publish JMeter Dashboard'
      inputs:
        PathtoPublish: '$(System.DefaultWorkingDirectory)/jmeter_dashboard'
        ArtifactName: 'JMeter-Dashboard'
      condition: always()

    # 5. Validaci√≥n del Resultado: Fallar si hay errores (c√≥digos != 200)
    - script: |
        echo "##[section] Validating JMeter Results (checking for non-200 responses)..."
        FAILURES=$(grep -c 'failure="true"' jmeter_results.xml)
        TOTAL_REQUESTS=$(grep -c '<httpSample' jmeter_results.xml)
        
        if [ "$FAILURES" -gt 0 ]; then
          echo "##[error] Performance Test FAILED: Found $FAILURES errors out of $TOTAL_REQUESTS requests."
          echo "##[error] El pipeline falla ya que se encontraron errores (no 200s) en las respuestas."
          exit 1
        else
          echo "‚úÖ Performance Test PASSED: All $TOTAL_REQUESTS requests were successful (HTTP 200 assertion passed)."
        fi
      displayName: '‚úÖ Validate Performance Results'